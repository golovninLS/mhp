MODULE TimesheetSupervisorLunch;

REQUIRE TimesheetSupervisor, TimesheetLunch, LunchOrder, ProjectLunchProduct, TimesheetSupervisorCustom, LunchProjectPayslip;

PRIORITY Lunch, MasterData;

NAMESPACE ProjectManagement;

CONSTRAINT SETCHANGED(timesheetLunchProduct()) AND timesheetProject() AND NOT in(timesheetProject(), timesheetLunchProduct()) CHECKED BY timesheetLunchProduct[]
    MESSAGE 'Выбранный вид обеда относится к другому проекту';

EXTEND FORM timesheetSupervisor
    PROPERTIES nameTimesheetLunchProduct()

    OBJECTS pel = (pl = Project, el = Employee)
    PROPERTIES READONLY nameProjectLunch 'Project' = name(pl)
    PROPERTIES(el) READONLY firstName, lastName, namePosition, rolesTimesheet
    FILTERS in(pl, currentUser()) OR showAllProjects(currentUser())
;

clearLunch 'Clear for date' (DATE d) {
    ASK 'This action cannot be undone. Continue ?' DO {
        LOCAL in = BOOLEAN (Project, Employee);
        LOCAL in = BOOLEAN (Product, Employee);
        in(Project p, Employee e) <- [FILTER timesheetSupervisor.pel](p, e);
        in(Product p, Employee e) <- TRUE WHERE (GROUP MIN Project pr IF in(pr, p) AND in(pr, e));
        
        NEWSESSION  NESTED (in[Product, Employee]) {
            DELETE Order o WHERE date(o) = d AND in(product(o), employee(o));
            APPLY;            
        }
    }
};

clearLunch 'Clear for employee' (Project p, Employee e) {
    ASK 'This action cannot be undone. Continue ?' DO {
        LOCAL in = BOOLEAN (DATE);
        in(DATE d) <- [FILTER timesheetSupervisor.d](d);
        NEWSESSION NESTED (in) {
            DELETE Order o WHERE in(date(o)) AND employee(o) = e AND in(p, product(o));
            APPLY;
        }
    }
} CONFIRM;

copyLunch 'Copy' (DATE d) {
    LOCAL in = BOOLEAN (Project, Employee);
    LOCAL in = BOOLEAN (Product, Employee);    
    
    in(Project p, Employee e) <- [FILTER timesheetSupervisor.pel](p, e);
    in(Product p, Employee e) <- TRUE WHERE (GROUP MIN Project pr IF in(pr, p) AND in(pr, e));
    
    ASK 'This action cannot be undone. Continue ?' IF (GROUP SUM 1 IF date(Order o) = d AND in(product(o), employee(o))) DO {
        NEWSESSION NESTED (in[Project, Employee], in[Product, Employee]) {
            LOCAL maxDate = DATE();
            maxDate() <- GROUP MAX date(Order o) IF date(o) < d AND in(product(o), employee(o));
            DELETE Order o WHERE date(o) = d AND in(product(o), employee(o));
            FOR date(Order o) = maxDate() AND hoursTimesheet(d, employee(o), Project p) AND in(p, employee(o)) AND in(p, product(o)) AND in(product(o), employee(o)) INLINE DO NEW on = Order {
                date(on) <- d;
                employee(on) <- employee(o);
                product(on) <- product(o);
                vendor(on) <- vendor(o);
                project(on) <- project(o);
            }
            APPLY;
        }
    }
} CONFIRM;

fillLunch 'Fill for date' (DATE d) {
    IF timesheetLunchProduct() THEN {
        LOCAL in = BOOLEAN (Project, Employee);
        LOCAL in = BOOLEAN (Product, Employee);
        LOCAL in = BOOLEAN (Employee);

        in(Project p, Employee e) <- [FILTER timesheetSupervisor.pel](p, e);
        in(Employee e) <- TRUE WHERE (GROUP MAX in(Project p, e));
        in(Product p, Employee e) <- TRUE WHERE (GROUP MIN Project pr IF in(pr, p) AND in(pr, e));
                
        ASK 'This action cannot be undone. Continue ?' IF (GROUP SUM 1 IF date(Order o) = d AND in(product(o), employee(o))) DO {
            NEWSESSION NESTED (in[Employee], in[Project, Employee], in[Product, Employee]) {
                DELETE Order o WHERE date(o) = d AND in(product(o), employee(o));
                FOR hoursTimesheet(d, Employee e, Project p) AND in(e) AND in(p, e) INLINE DO NEW o = Order {
                    date(o) <- d;
                    employee(o) <- e;
                    product(o) <- timesheetLunchProduct();
                    project(o) <- timesheetProject();
                }
                APPLY;
            }
        }
    } ELSE
        MESSAGE 'Lunch product is not specified';
}

fillLunch 'Fill for employee' (Project p, Employee e) {
    IF timesheetLunchProduct() THEN {
        LOCAL in = BOOLEAN (DATE);
        in(DATE d) <- [FILTER timesheetSupervisor.d](d);
        ASK 'This action cannot be undone. Continue ?' IF (GROUP SUM 1 IF in(date(Order o)) AND employee(o) = e AND in(p, product(o))) DO {
            NEWSESSION NESTED (in) {
                DELETE Order o WHERE in(date(o)) AND employee(o) = e AND in(p, product(o));
                FOR hoursTimesheet(DATE d, e, p) AND in(d) INLINE DO NEW o = Order {
                    date(o) <- d;
                    employee(o) <- e;
                    product(o) <- timesheetLunchProduct();
                    project(o) <- timesheetProject();
                }
                APPLY;
            }
        }
    } ELSE
        MESSAGE 'Lunch product is not specified';
}

rgbColorProduct (Order o) = rgbColor(product(o));
rgbColorProductOrder 'Symbols' (DATE d, Employee e) = rgbColorProduct(order(d, e));;

countLunchProduct 'Lunch (days)' (Project p, Employee e, DATE from, DATE to) =
    GROUP SUM 1 IF in(p, productOrder(DATE d, e)) AND iterate(d, from, to);
countLunchProduct 'Lunch (days)' (Project p, Employee e, INTERVAL[DATE] i) = countLunchProduct(p, e, from(i), to(i));

symbolProduct 'Symbol' (Order o) = symbol(product(o));
nameProduct '{master.data.name}' (Order o) = name(product(o));

productOrder (DATE d, Employee e, Project p) = product(order(d, e)) IF in(p, product(order(d, e)));
symbolProductOrder 'Lunch order' (DATE d, Employee e, Project p) = symbol(productOrder(d, e, p));

lunches 'Lunches' (DATE d, Employee e) =
    GROUP SUM 1 IF productOrder(d, e);
lunches 'Lunches' (DATE d, Employee e, Project p) = GROUP SUM 1 IF order(d, e) AND project(order(d, e)) = p;

lunchesT 'Lunches' (DATE d) = GROUP SUM lunches(d, Employee e);
lunchesT 'Lunches' (DATE d, Project p) = GROUP SUM 1 IF productOrder(d, Employee e, p);

FORM timesheetSupervisorDateEmployeeLuncheOrders 'Lunches'
    OBJECTS i = INTERVAL[DATE] PANEL
    OBJECTS e = Employee PANEL

    OBJECTS o = Order
    PROPERTIES(o) READONLY date, symbolProduct, nameProduct
    PROPERTIES(o) EDIT, DELETE
    ORDERS date(o)
    FILTERS date(o) >= from(i) AND date(o) <= to(i),
        employee(o) = e
;

EXTEND FORM timesheetSupervisor
    PROPERTIES symbolProductOrder(d, el, pl) WAIT COLUMNS (d) HEADER extractDay(d) BACKGROUND backgroundHoursTimesheet(d, el)
    ON CHANGE {
        FOR Product lp = timesheetLunchProduct() AND timesheetProject() DO
            NEWSESSION {
                FOR Order o = order(d, el) DO {
                    IF product(o) = lp THEN
                        DELETE o;
                    ELSE
                        product(o) <- lp;
                } ELSE {
                    NEW o = Order {
                        date(o) <- d;
                        employee(o) <- el;
                        project(o) <- timesheetProject();
                        product(o) <- lp;
                    }
                }
                APPLY;
            }
            ELSE
        SHOW timesheetSupervisorDateEmployeeLuncheOrders OBJECTS i = interval(d, d), e = el FLOAT;
    } ON CONTEXTMENU clearLunch(d) ON CONTEXTMENU fillLunch(d)
    ON CONTEXTMENU clearLunch(pl, el) ON CONTEXTMENU fillLunch(pl, el)
    ON CONTEXTMENU copyLunch(d)
    FOOTER (IF timesheetProject() THEN lunchesT(d, timesheetProject()) ELSE lunchesT(d))

    FILTERS assigned(pl, el, dates) OR hours(el, pl, dates) OR (NOT countAssignments(pl) AND NOT countAssignments(currentUser()))
    FILTERS pl == timesheetProject() OR NOT timesheetProject()
    FILTERS in(pl, timesheetLunchProduct()) OR NOT timesheetLunchProduct()

    FILTERGROUP onlyFilledLunch
        FILTER 'Только заполненные' countLunchProduct(pl, el, dates)
;

DESIGN timesheetSupervisor {
    tabbedPane {
        NEW lunch {
            caption = 'Lunches';
            MOVE PROPERTY(nameTimesheetLunchProduct()) { alignment = START; }
            MOVE BOX(pel) {
                caption = '';
            }
        }
    }
}

EXTEND FORM timesheetSupervisor
    PROPERTIES countLunches(el, pl, dates) BEFORE symbolProductOrder(d, el, pl)
;